<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 12: Mini Toolkit Refactor &amp; Testing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e0e0e0;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #0d0d0d;
            border: 2px solid #cc0000;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(204, 0, 0, 0.3);
        }

        header {
            background: linear-gradient(135deg, #cc0000 0%, #990000 100%);
            padding: 30px;
            text-align: center;
            border-bottom: 3px solid #ff0000;
        }

        h1 {
            font-size: 2.5em;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #ffcccc;
            font-weight: normal;
        }

        .progress-bar-container {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .progress-bar-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #fff;
            font-size: 0.9em;
        }

        .progress-bar-label strong {
            font-size: 1.1em;
        }

        .progress-percentage {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .progress-bar-track {
            width: 100%;
            height: 30px;
            background: #000;
            border-radius: 15px;
            border: 2px solid #cc0000;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #cc0000 0%, #ff0000 50%, #00ff00 100%);
            border-radius: 13px;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(204, 0, 0, 0.6);
            position: relative;
            animation: progressPulse 2s ease-in-out infinite;
        }

        @keyframes progressPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(204, 0, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 30px rgba(204, 0, 0, 0.9);
            }
        }

        .progress-bar-fill.complete {
            animation: progressComplete 1s ease-in-out;
            background: linear-gradient(90deg, #00ff00 0%, #00ff00 100%);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
        }

        @keyframes progressComplete {
            0% {
                transform: scaleX(0.95);
            }
            50% {
                transform: scaleX(1.02);
                box-shadow: 0 0 40px rgba(0, 255, 0, 1);
            }
            100% {
                transform: scaleX(1);
            }
        }

        .progress-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, 
                rgba(255, 255, 255, 0.3) 0%, 
                rgba(255, 255, 255, 0) 50%, 
                rgba(0, 0, 0, 0.3) 100%);
        }

        .progress-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 0.85em;
            color: #ccc;
        }

        .progress-stat {
            text-align: center;
        }

        .progress-stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff6666;
        }

        .progress-stat-label {
            color: #999;
            margin-top: 2px;
        }

        .nav-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 2px solid #cc0000;
            overflow-x: auto;
        }

        .nav-tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: #2d2d2d;
            color: #999;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            border-right: 1px solid #444;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .nav-tab:hover {
            background: #3d3d3d;
            color: #ccc;
        }

        .nav-tab.active {
            background: #cc0000;
            color: #fff;
            border-bottom: 3px solid #ff0000;
        }

        .content {
            padding: 30px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h2 {
            color: #cc0000;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 2px solid #cc0000;
            padding-bottom: 10px;
        }

        h3 {
            color: #ff3333;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h4 {
            color: #ff6666;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .objective-box {
            background: #1a1a1a;
            border-left: 4px solid #cc0000;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .objective-box h3 {
            margin-top: 0;
            color: #ff3333;
        }

        .objective-list {
            list-style: none;
            padding-left: 0;
        }

        .objective-list li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }

        .objective-list li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #cc0000;
            font-weight: bold;
        }

        .code-block {
            background: #000;
            border: 1px solid #cc0000;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
        }

        .code-block code {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            display: block;
            white-space: pre;
        }

        .code-label {
            position: absolute;
            top: 5px;
            right: 10px;
            background: #cc0000;
            color: #fff;
            padding: 3px 10px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 968px) {
            .comparison-container {
                grid-template-columns: 1fr;
            }
            
            .progress-stats {
                flex-direction: column;
                gap: 10px;
            }
            
            .progress-bar-label {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
        }

        .before-code {
            background: #1a0000;
            border: 2px solid #cc0000;
            border-radius: 4px;
            padding: 15px;
        }

        .after-code {
            background: #001a00;
            border: 2px solid #00cc00;
            border-radius: 4px;
            padding: 15px;
        }

        .before-code h4 {
            color: #ff3333;
            margin-top: 0;
        }

        .after-code h4 {
            color: #33ff33;
            margin-top: 0;
        }

        .info-box {
            background: #1a1a2e;
            border: 1px solid #4a4a6a;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .warning-box {
            background: #2e1a1a;
            border: 1px solid #cc0000;
            border-left: 4px solid #cc0000;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .tip-box {
            background: #1a2e1a;
            border: 1px solid #00cc00;
            border-left: 4px solid #00cc00;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .exercise-box {
            background: #2d2d2d;
            border: 2px solid #cc0000;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }

        .exercise-box h3 {
            color: #ff6666;
            margin-top: 0;
        }

        .exercise-input {
            width: 100%;
            min-height: 200px;
            background: #000;
            color: #00ff00;
            border: 1px solid #cc0000;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 15px 0;
            resize: vertical;
        }

        .btn {
            background: #cc0000;
            color: #fff;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn:hover {
            background: #ff0000;
            box-shadow: 0 0 15px rgba(204, 0, 0, 0.5);
        }

        .btn-secondary {
            background: #555;
        }

        .btn-secondary:hover {
            background: #777;
        }

        .feedback {
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            display: none;
        }

        .feedback.success {
            background: #1a4d1a;
            border: 1px solid #00ff00;
            color: #00ff00;
            display: block;
        }

        .feedback.error {
            background: #4d1a1a;
            border: 1px solid #ff0000;
            color: #ff6666;
            display: block;
        }

        .progress-tracker {
            background: #1a1a1a;
            border: 2px solid #cc0000;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .progress-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #0d0d0d;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .progress-item:hover {
            background: #2d2d2d;
        }

        .progress-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #cc0000;
            border-radius: 3px;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff00;
            font-weight: bold;
        }

        .progress-item.completed .progress-checkbox {
            background: #cc0000;
        }

        .ai-prompt-box {
            background: #1a1a2e;
            border: 2px solid #6666ff;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .ai-prompt-box h4 {
            color: #8888ff;
            margin-top: 0;
        }

        .prompt-text {
            background: #0d0d1a;
            border: 1px solid #4444aa;
            border-radius: 4px;
            padding: 10px;
            color: #aaaaff;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #1a1a1a;
        }

        th {
            background: #cc0000;
            color: #fff;
            padding: 12px;
            text-align: left;
            border: 1px solid #990000;
        }

        td {
            padding: 10px;
            border: 1px solid #444;
        }

        tr:nth-child(even) {
            background: #0d0d0d;
        }

        .mitre-tag {
            display: inline-block;
            background: #2d2d2d;
            border: 1px solid #cc0000;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 0.85em;
            margin: 2px;
            color: #ff6666;
        }

        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .scenario-box {
            background: #1a1a1a;
            border: 2px solid #cc0000;
            border-radius: 8px;
            padding: 25px;
            margin: 25px 0;
        }

        .scenario-box h3 {
            color: #ff3333;
            margin-top: 0;
        }

        footer {
            background: #000;
            color: #666;
            text-align: center;
            padding: 20px;
            border-top: 2px solid #cc0000;
            margin-top: 40px;
        }
    </style>
</head><body><div class="container"><header>
<h1>‚öôÔ∏è WEEK 12: MINI TOOLKIT REFACTOR &amp; TESTING</h1>
<p class="subtitle">Modularization | Logging | Unit Tests | CLI Design | AI-Assisted Development</p>
<div class="progress-bar-container">
<div class="progress-bar-label"><strong>Your Overall Progress</strong> <span class="progress-percentage" id="progressPercentage">0%</span></div>
<div class="progress-bar-track">
<div class="progress-bar-fill" id="progressBarFill" style="width: 0%;"></div>
</div>
<div class="progress-stats">
<div class="progress-stat">
<div class="progress-stat-value" id="completedCount">0</div>
<div class="progress-stat-label">Completed</div>
</div>
<div class="progress-stat">
<div class="progress-stat-value" id="totalCount">36</div>
<div class="progress-stat-label">Total Items</div>
</div>
<div class="progress-stat">
<div class="progress-stat-value" id="remainingCount">36</div>
<div class="progress-stat-label">Remaining</div>
</div>
</div>
</div>
</header>
<div class="nav-tabs"><button class="nav-tab active" onclick="switchTab('overview')">üìã Overview</button> <button class="nav-tab" onclick="switchTab('scenario')">üéØ Scenario</button> <button class="nav-tab" onclick="switchTab('refactoring')">üîß Refactoring</button> <button class="nav-tab" onclick="switchTab('logging')">üìù Logging</button> <button class="nav-tab" onclick="switchTab('testing')">‚úÖ Testing</button> <button class="nav-tab" onclick="switchTab('cli')">‚å®Ô∏è CLI Design</button> <button class="nav-tab" onclick="switchTab('ai')">ü§ñ AI Assistant</button> <button class="nav-tab" onclick="switchTab('exercises')">üíª Exercises</button> <button class="nav-tab" onclick="switchTab('progress')">üìä Progress</button></div>
<div class="content"><!-- OVERVIEW TAB -->
<div id="overview" class="tab-content active">
<h2>üìã Week 12 Overview: Consolidation &amp; Best Practices</h2>
<div class="objective-box">
<h3>üéØ Learning Objectives</h3>
<ul class="objective-list">
<li>Transform monolithic scripts into modular, testable code</li>
<li>Implement proper logging and error handling strategies</li>
<li>Write unit tests using both unittest and pytest frameworks</li>
<li>Design professional command-line interfaces with argparse</li>
<li>Leverage AI tools for refactoring and test generation</li>
<li>Apply software engineering best practices to security tools</li>
</ul>
</div>
<div class="info-box">
<h3>üìö What You'll Build This Week</h3>
<p>You'll take a messy, monolithic <strong>Network Traffic Monitor</strong> script and transform it into a professional, maintainable tool with:</p>
<ul>
<li>Clean modular architecture with reusable functions</li>
<li>Comprehensive logging for debugging and audit trails</li>
<li>Robust error handling with meaningful messages</li>
<li>Full unit test coverage (unittest and pytest)</li>
<li>Professional CLI with --help, --input, --output flags</li>
<li>AI-assisted development workflow</li>
</ul>
</div>
<h3>üîë Key Concepts</h3>
<table>
<tbody>
<tr>
<th>Concept</th>
<th>Description</th>
<th>Why It Matters</th>
</tr>
<tr>
<td><strong>Refactoring</strong></td>
<td>Restructuring code without changing behavior</td>
<td>Improves maintainability, reduces bugs, enables testing</td>
</tr>
<tr>
<td><strong>Modularization</strong></td>
<td>Breaking code into reusable functions/modules</td>
<td>Promotes code reuse, easier debugging, team collaboration</td>
</tr>
<tr>
<td><strong>Logging</strong></td>
<td>Recording program events for monitoring/debugging</td>
<td>Essential for production systems, incident response, compliance</td>
</tr>
<tr>
<td><strong>Unit Testing</strong></td>
<td>Testing individual functions in isolation</td>
<td>Catches bugs early, enables confident refactoring, documentation</td>
</tr>
<tr>
<td><strong>CLI Design</strong></td>
<td>Creating user-friendly command-line interfaces</td>
<td>Professional tools, automation-friendly, follows Unix philosophy</td>
</tr>
</tbody>
</table>
<h3>üîí MITRE ATT&amp;CK Relevance</h3>
<div class="warning-box">
<p><strong>Why This Matters for Security:</strong></p>
<p>Professional security tools require rigorous testing and logging because:</p>
<ul>
<li><span class="mitre-tag">T1040 - Network Sniffing</span> Tools must accurately capture and parse traffic without dropping packets</li>
<li><span class="mitre-tag">T1595 - Active Scanning</span> Detection systems need comprehensive logs for forensic analysis</li>
<li><span class="mitre-tag">T1562 - Impair Defenses</span> Attackers target poorly-tested security tools with known bugs</li>
</ul>
<p><strong>Real-world impact:</strong> A bug in Snort IDS signature parsing went undetected for months because of inadequate testing, allowing attackers to bypass detection using malformed packets.</p>
</div>
<h3>üìñ Week Structure</h3>
<ol>
<li><strong>Scenario Introduction:</strong> Review the messy "before" code</li>
<li><strong>Refactoring Patterns:</strong> Learn to extract functions, eliminate globals, remove magic numbers</li>
<li><strong>Logging Implementation:</strong> Add structured logging with appropriate levels</li>
<li><strong>Testing Fundamentals:</strong> Write unit tests with unittest and pytest</li>
<li><strong>CLI Enhancement:</strong> Build professional command-line interface</li>
<li><strong>AI Integration:</strong> Use AI as a refactoring and testing partner</li>
<li><strong>Hands-on Exercises:</strong> Apply all concepts to complete the transformation</li>
</ol>
<div class="tip-box">
<h4>üí° Success Tips</h4>
<ul>
<li><strong>Test early, test often:</strong> Don't wait until the end to write tests</li>
<li><strong>One change at a time:</strong> Refactor incrementally and test after each change</li>
<li><strong>Use AI critically:</strong> AI suggestions are a starting point, not gospel</li>
<li><strong>Log strategically:</strong> Too much logging is noise; too little misses key events</li>
<li><strong>Think about users:</strong> Your CLI should be intuitive and well-documented</li>
</ul>
</div>
</div>
<!-- SCENARIO TAB -->
<div id="scenario" class="tab-content">
<h2>üéØ The Scenario: Network Traffic Monitor</h2>
<div class="scenario-box">
<h3>üì° MedSecure Health Systems - Network Monitoring Challenge</h3>
<p><strong>Context:</strong> You're a junior security analyst at MedSecure Health Systems. The previous analyst left behind a Python script that monitors network traffic for suspicious patterns, but it's become unmaintainable:</p>
<ul>
<li>Everything is in one massive function</li>
<li>No error handling - crashes on bad input</li>
<li>Debug print() statements everywhere</li>
<li>Magic numbers and hardcoded values</li>
<li>No tests - every change breaks something</li>
<li>Command-line arguments are a mess</li>
</ul>
<p><strong>Your Mission:</strong> Transform this into a professional security tool that the team can maintain, extend, and trust.</p>
</div>
<h3>üî¥ The "Before" Code (Messy Version)</h3>
<div class="code-block"><span class="code-label">BAD EXAMPLE</span> <code>#!/usr/bin/env python3
# network_monitor.py - BEFORE REFACTORING
import sys

# Global variables everywhere
total_packets = 0
suspicious_packets = 0
port_scan_threshold = 25
syn_threshold = 100
log_file = "network.log"

def analyze_traffic(file_path):
    global total_packets, suspicious_packets
    
    print("Starting analysis...")
    
    # No error handling!
    f = open(file_path, 'r')
    lines = f.readlines()
    f.close()
    
    suspicious_ips = {}
    port_scans = {}
    
    for line in lines:
        if line.strip() == "":
            continue
        
        total_packets += 1
        
        # Magic numbers everywhere - what do these mean?
        parts = line.split(',')
        if len(parts) != 6:
            print("Bad line:", line)
            continue
        
        src_ip = parts[0]
        dst_ip = parts[1]
        src_port = parts[2]
        dst_port = parts[3]
        protocol = parts[4]
        flags = parts[5].strip()
        
        # Hardcoded logic - no explanation
        if protocol == "TCP" and flags == "SYN":
            if src_ip not in suspicious_ips:
                suspicious_ips[src_ip] = 0
            suspicious_ips[src_ip] += 1
        
        # Port scan detection - magic number 25
        key = src_ip + "-" + dst_ip
        if key not in port_scans:
            port_scans[key] = set()
        port_scans[key].add(dst_port)
        
        if len(port_scans[key]) &gt; 25:
            suspicious_packets += 1
            print(f"PORT SCAN ALERT: {src_ip} scanning {dst_ip}")
    
    # More hardcoded thresholds
    print("\n=== Analysis Results ===")
    print(f"Total packets: {total_packets}")
    print(f"Suspicious packets: {suspicious_packets}")
    print("\nHigh SYN sources:")
    for ip, count in suspicious_ips.items():
        if count &gt; 100:  # Another magic number!
            print(f"  {{ip}}: {{count}} SYN packets")
    
    # Write to hardcoded log file
    with open(log_file, 'w') as lf:
        lf.write(f"Analysis completed. Total: {total_packets}\n")

# Terrible argument parsing
if __name__ == "__main__":
    if len(sys.argv) &lt; 2:
        print("Usage: python network_monitor.py <file>")
        sys.exit(1)
    
    analyze_traffic(sys.argv[1])
    print("Done!")</file></code></div>
<div class="warning-box">
<h4>‚ùå Problems with This Code</h4>
<ol>
<li><strong>No Modularity:</strong> Everything in one giant function - can't test or reuse anything</li>
<li><strong>Global State:</strong> Global variables make testing impossible and cause bugs</li>
<li><strong>Magic Numbers:</strong> What do 25, 100 mean? Why those thresholds?</li>
<li><strong>No Error Handling:</strong> Crashes on malformed input or missing files</li>
<li><strong>Poor Logging:</strong> print() statements everywhere, no log levels, no structure</li>
<li><strong>Untestable:</strong> Side effects, file I/O, globals - impossible to unit test</li>
<li><strong>Bad CLI:</strong> Manual sys.argv parsing, no --help, no validation</li>
<li><strong>No Documentation:</strong> What does this code do? How do I use it?</li>
</ol>
</div>
<h3>‚úÖ What We'll Improve</h3>
<div class="tip-box">
<p>By the end of this week, you'll transform this into a tool with:</p>
<ul>
<li>Pure functions with single responsibilities</li>
<li>Configuration classes instead of magic numbers</li>
<li>Proper logging with levels (DEBUG, INFO, WARNING, ERROR)</li>
<li>Comprehensive error handling with meaningful messages</li>
<li>Full unit test coverage with both unittest and pytest</li>
<li>Professional argparse CLI with --help and validation</li>
<li>Clear documentation and type hints</li>
</ul>
</div>
</div>
<!-- REFACTORING TAB -->
<div id="refactoring" class="tab-content">
<h2>üîß Refactoring: From Mess to Module</h2>
<div class="info-box">
<h3>What is Refactoring?</h3>
<p><strong>Refactoring</strong> is the process of restructuring existing code without changing its external behavior. Think of it like renovating a house - the house still works, but the internal structure is cleaner, safer, and easier to maintain.</p>
</div>
<h3>Step 1: Extract Configuration</h3>
<p>Replace magic numbers and globals with a configuration class:</p>
<div class="comparison-container">
<div class="before-code">
<h4>‚ùå Before: Magic Numbers</h4>
<div class="code-block"><code># Scattered throughout code
port_scan_threshold = 25
syn_threshold = 100
log_file = "network.log"

if len(port_scans[key]) &gt; 25:
    # Alert!

if count &gt; 100:
    # Suspicious!</code></div>
</div>
<div class="after-code">
<h4>‚úÖ After: Configuration Class</h4>
<div class="code-block"><code>class NetworkConfig:
    """Configuration for network analysis"""
    PORT_SCAN_THRESHOLD = 25
    SYN_FLOOD_THRESHOLD = 100
    DEFAULT_LOG_FILE = "network.log"
    
    def __init__(self, 
                 port_scan=25, 
                 syn_flood=100):
        self.port_scan_threshold = port_scan
        self.syn_flood_threshold = syn_flood

# Now it's clear what each value means!
config = NetworkConfig()</code></div>
</div>
</div>
<h3>Step 2: Extract Pure Functions</h3>
<p>Break the monolith into small, testable functions with single responsibilities:</p>
<div class="comparison-container">
<div class="before-code">
<h4>‚ùå Before: Everything in One Function</h4>
<div class="code-block"><code>def analyze_traffic(file_path):
    # 150 lines of mixed logic
    # Parsing, analysis, alerting, 
    # file I/O all tangled together
    # Impossible to test!</code></div>
</div>
<div class="after-code">
<h4>‚úÖ After: Modular Functions</h4>
<div class="code-block"><code>def parse_packet_line(line: str) -&gt; dict:
    """Parse a single packet line.
    Pure function - easy to test!"""
    pass

def is_port_scan(packets: list, 
                 threshold: int) -&gt; bool:
    """Detect port scan patterns.
    Pure function - no side effects!"""
    pass

def analyze_traffic(file_path: str, 
                   config: NetworkConfig):
    """Main orchestration function"""
    packets = load_packets(file_path)
    results = analyze_packets(packets)
    return results</code></div>
</div>
</div>
<h3>Key Refactoring Patterns</h3>
<h4>Pattern 1: Extract Function</h4>
<div class="code-block"><code># When you see a block of code with a comment explaining it,
# that's a function waiting to be born!

# BEFORE
# Check if this is a SYN flood attack
if protocol == "TCP" and flags == "SYN":
    if src_ip not in suspicious_ips:
        suspicious_ips[src_ip] = 0
    suspicious_ips[src_ip] += 1

# AFTER
def is_syn_packet(packet: dict) -&gt; bool:
    """Check if packet is a TCP SYN packet."""
    return packet['protocol'] == 'TCP' and packet['flags'] == 'SYN'

def track_syn_packets(syn_tracker: dict, packet: dict) -&gt; None:
    """Update SYN packet tracking for source IP."""
    src_ip = packet['src_ip']
    syn_tracker[src_ip] = syn_tracker.get(src_ip, 0) + 1</code></div>
<h4>Pattern 2: Replace Primitive with Object</h4>
<div class="code-block"><code># BEFORE: Dictionary with magic keys
packet = {
    'src': '192.168.1.5',
    'dst': '10.0.0.1',
    'sport': '54321',
    'dport': '443'
}

# AFTER: Named class with validation
class NetworkPacket:
    def __init__(self, src_ip, dst_ip, src_port, dst_port, protocol, flags):
        self.src_ip = self._validate_ip(src_ip)
        self.dst_ip = self._validate_ip(dst_ip)
        self.src_port = int(src_port)
        self.dst_port = int(dst_port)
        self.protocol = protocol.upper()
        self.flags = flags.strip()
    
    @staticmethod
    def _validate_ip(ip: str) -&gt; str:
        """Validate IP address format."""
        parts = ip.split('.')
        if len(parts) != 4:
            raise ValueError(f"Invalid IP: {{ip}}")
        return ip
    
    def is_syn(self) -&gt; bool:
        """Check if this is a SYN packet."""
        return self.protocol == 'TCP' and self.flags == 'SYN'</code></div>
<h4>Pattern 3: Separate I/O from Logic</h4>
<div class="code-block"><code># BEFORE: Logic mixed with I/O (hard to test)
def analyze_traffic(file_path):
    f = open(file_path, 'r')  # I/O
    for line in f:             # I/O
        if is_suspicious(line):  # Logic
            print("Alert!")      # I/O

# AFTER: Separate concerns
def load_packets(file_path: str) -&gt; list:
    """I/O function - handles file reading only."""
    with open(file_path, 'r') as f:
        return [line.strip() for line in f if line.strip()]

def analyze_packets(packet_lines: list, config: NetworkConfig) -&gt; dict:
    """Pure logic function - takes data, returns results.
    Easy to test with fake data!"""
    results = {
        'total': len(packet_lines),
        'suspicious': [],
        'port_scans': []
    }
    
    for line in packet_lines:
        packet = parse_packet_line(line)
        if is_suspicious_packet(packet, config):
            results['suspicious'].append(packet)
    
    return results

def main(file_path: str, config: NetworkConfig):
    """Orchestration - glues I/O and logic together."""
    packets = load_packets(file_path)
    results = analyze_packets(packets, config)
    return results</code></div>
<div class="tip-box">
<h4>üí° Refactoring Best Practices</h4>
<ul>
<li><strong>Make one change at a time</strong> - refactor incrementally and test after each change</li>
<li><strong>Keep tests green</strong> - if you have tests, make sure they pass after each refactor</li>
<li><strong>Use version control</strong> - commit working code frequently so you can rollback</li>
<li><strong>Pure functions are gold</strong> - functions with no side effects are easiest to test and reuse</li>
<li><strong>Name things well</strong> - good names eliminate the need for comments</li>
</ul>
</div>
<h3>Refactoring Checklist</h3>
<div class="info-box">
<p>When refactoring security code, ask yourself:</p>
<ol>
<li>‚ùì Can I extract this logic into a pure function?</li>
<li>‚ùì Are there any magic numbers that should be constants?</li>
<li>‚ùì Is this function doing more than one thing?</li>
<li>‚ùì Can I separate I/O from business logic?</li>
<li>‚ùì Would a class make this data structure clearer?</li>
<li>‚ùì Are my function names describing what they do?</li>
<li>‚ùì Can I write a unit test for this function?</li>
</ol>
</div>
</div>
<!-- LOGGING TAB -->
<div id="logging" class="tab-content">
<h2>üìù Logging: Professional Diagnostics</h2>
<div class="info-box">
<h3>Why Logging Matters in Security</h3>
<p>In cybersecurity, logs are your forensic evidence. When an incident occurs, logs tell you:</p>
<ul>
<li>What happened (events)</li>
<li>When it happened (timestamps)</li>
<li>Who was involved (actors)</li>
<li>What was the impact (results)</li>
</ul>
<p><strong>Without proper logging, you're flying blind.</strong></p>
</div>
<h3>print() vs. logging</h3>
<div class="comparison-container">
<div class="before-code">
<h4>‚ùå Using print() (Bad)</h4>
<div class="code-block"><code># Problems:
# - No timestamps
# - No severity levels
# - Can't filter or disable
# - Mixed with actual output
# - No structured format

print("Starting analysis...")
print("Processing packet:", packet)
print("ERROR: Bad packet format")
print("Found suspicious IP")
print("Done!")</code></div>
</div>
<div class="after-code">
<h4>‚úÖ Using logging (Good)</h4>
<div class="code-block"><code>import logging

logger = logging.getLogger(__name__)

# Benefits:
# - Automatic timestamps
# - Severity levels (DEBUG/INFO/WARN/ERROR)
# - Can filter by level
# - Can route to files/services
# - Structured format

logger.info("Starting analysis")
logger.debug("Processing packet: %s", packet)
logger.error("Bad packet format at line %d", line_num)
logger.warning("Suspicious IP detected: %s", ip)
logger.info("Analysis complete")</code></div>
</div>
</div>
<h3>Log Levels Explained</h3>
<table>
<tbody>
<tr>
<th>Level</th>
<th>When to Use</th>
<th>Example</th>
</tr>
<tr>
<td><strong style="color: #666;">DEBUG</strong></td>
<td>Detailed diagnostic info for developers</td>
<td>"Parsed packet: src=192.168.1.5, dst=10.0.0.1"</td>
</tr>
<tr>
<td><strong style="color: #00cc00;">INFO</strong></td>
<td>General informational messages about progress</td>
<td>"Analysis started on traffic.log (1500 packets)"</td>
</tr>
<tr>
<td><strong style="color: #ffaa00;">WARNING</strong></td>
<td>Something unusual but system continues</td>
<td>"Packet from 192.168.1.5 exceeds SYN threshold"</td>
</tr>
<tr>
<td><strong style="color: #ff3333;">ERROR</strong></td>
<td>Something failed but program continues</td>
<td>"Failed to parse line 42: invalid format"</td>
</tr>
<tr>
<td><strong style="color: #cc0000;">CRITICAL</strong></td>
<td>Serious failure, program may exit</td>
<td>"Cannot open traffic log file: permission denied"</td>
</tr>
</tbody>
</table>
<h3>Setting Up Logging</h3>
<div class="code-block"><code>import logging
from pathlib import Path

def setup_logging(log_file: str = "network_monitor.log", 
                  log_level: str = "INFO") -&gt; logging.Logger:
    """Configure logging with both file and console output."""
    
    # Convert string level to logging constant
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    
    # Create logger
    logger = logging.getLogger("network_monitor")
    logger.setLevel(numeric_level)
    
    # Clear any existing handlers
    logger.handlers = []
    
    # File handler - detailed logs
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.DEBUG)  # Log everything to file
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    file_handler.setFormatter(file_formatter)
    
    # Console handler - less verbose
    console_handler = logging.StreamHandler()
    console_handler.setLevel(numeric_level)  # Use configured level
    console_formatter = logging.Formatter(
        '%(levelname)s: %(message)s'
    )
    console_handler.setFormatter(console_formatter)
    
    # Add handlers
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

# Usage
logger = setup_logging(log_file="analysis.log", log_level="DEBUG")</code></div>
<h3>Effective Logging Patterns</h3>
<h4>Pattern 1: Log Entry and Exit Points</h4>
<div class="code-block"><code>def analyze_traffic(file_path: str, config: NetworkConfig) -&gt; dict:
    """Analyze network traffic for suspicious patterns."""
    logger.info("Starting traffic analysis on %s", file_path)
    
    try:
        packets = load_packets(file_path)
        logger.info("Loaded %d packets", len(packets))
        
        results = analyze_packets(packets, config)
        logger.info("Analysis complete: %d suspicious packets found", 
                   len(results['suspicious']))
        
        return results
        
    except Exception as e:
        logger.error("Analysis failed: %s", str(e), exc_info=True)
        raise</code></div>
<h4>Pattern 2: Log Important Decisions</h4>
<div class="code-block"><code>def is_port_scan(src_ip: str, target_ports: set, threshold: int) -&gt; bool:
    """Detect if IP is performing a port scan."""
    port_count = len(target_ports)
    
    if port_count &gt; threshold:
        logger.warning(
            "Port scan detected: %s scanned %d ports (threshold: %d)",
            src_ip, port_count, threshold
        )
        return True
    else:
        logger.debug(
            "No port scan: %s contacted %d ports (threshold: %d)",
            src_ip, port_count, threshold
        )
        return False</code></div>
<h4>Pattern 3: Log Errors with Context</h4>
<div class="code-block"><code>def parse_packet_line(line: str, line_number: int = 0) -&gt; NetworkPacket:
    """Parse a packet line with error handling."""
    try:
        parts = line.split(',')
        if len(parts) != 6:
            raise ValueError(f"Expected 6 fields, got {len(parts)}")
        
        return NetworkPacket(*parts)
        
    except ValueError as e:
        logger.error(
            "Parse error at line %d: %s. Line content: '%s'",
            line_number, str(e), line[:50]  # Truncate long lines
        )
        raise
    except Exception as e:
        logger.error(
            "Unexpected error parsing line %d: %s",
            line_number, str(e), exc_info=True  # Include full traceback
        )
        raise</code></div>
<h4>Pattern 4: Security Event Logging</h4>
<div class="code-block"><code>def log_security_event(event_type: str, src_ip: str, details: dict) -&gt; None:
    """Log security events in a structured format for SIEM ingestion."""
    
    # Structured logging for security events
    logger.warning(
        "SECURITY_EVENT | Type: %s | Source: %s | Details: %s",
        event_type, src_ip, details
    )
    
    # Could also use JSON format for SIEM:
    # import json
    # event = {
    #     'timestamp': datetime.now().isoformat(),
    #     'event_type': event_type,
    #     'src_ip': src_ip,
    #     'details': details
    # }
    # logger.warning(json.dumps(event))</code></div>
<div class="warning-box">
<h4>‚ö†Ô∏è Logging Pitfalls to Avoid</h4>
<ol>
<li><strong>Don't log sensitive data:</strong> No passwords, API keys, PII, credit cards</li>
<li><strong>Don't log too much:</strong> DEBUG level in production creates noise and performance issues</li>
<li><strong>Don't log too little:</strong> You need enough context to debug issues</li>
<li><strong>Don't use string formatting in log calls:</strong> Use % formatting so lazy evaluation works: <code style="display: block; margin-top: 10px;">
# BAD: Always evaluates expensive_function()
logger.debug("Value: " + expensive_function())

# GOOD: Only evaluates if DEBUG enabled
logger.debug("Value: %s", expensive_function())</code></li>
</ol>
</div>
<div class="tip-box">
<h4>üí° Logging Best Practices for Security Tools</h4>
<ul>
<li><strong>Use structured logging:</strong> Makes it easy to parse logs programmatically</li>
<li><strong>Include timestamps:</strong> Essential for forensic analysis and correlation</li>
<li><strong>Log both success and failure:</strong> Negative evidence is important too</li>
<li><strong>Be consistent:</strong> Use same format across your codebase</li>
<li><strong>Think about log rotation:</strong> Old logs should be archived/deleted</li>
<li><strong>Consider your audience:</strong> DEBUG for devs, INFO for ops, WARNING for security team</li>
</ul>
</div>
</div>
<!-- TESTING TAB -->
<div id="testing" class="tab-content">
<h2>‚úÖ Unit Testing: Catch Bugs Before They Bite</h2>
<div class="info-box">
<h3>Why Write Tests?</h3>
<p><strong>Security tools must be reliable.</strong> A bug in your intrusion detection system could mean missed attacks. Testing gives you:</p>
<ul>
<li><strong>Confidence:</strong> Code does what you think it does</li>
<li><strong>Regression prevention:</strong> New changes don't break old features</li>
<li><strong>Documentation:</strong> Tests show how functions should be used</li>
<li><strong>Refactoring safety:</strong> Change code without fear</li>
<li><strong>Design feedback:</strong> Hard-to-test code is often poorly designed</li>
</ul>
</div>
<h3>unittest vs. pytest</h3>
<table>
<tbody>
<tr>
<th>Feature</th>
<th>unittest (Standard Library)</th>
<th>pytest (Third-party)</th>
</tr>
<tr>
<td><strong>Installation</strong></td>
<td>Built into Python</td>
<td>Requires: pip install pytest</td>
</tr>
<tr>
<td><strong>Test Style</strong></td>
<td>Class-based, requires inheritance</td>
<td>Simple functions, more Pythonic</td>
</tr>
<tr>
<td><strong>Assertions</strong></td>
<td>self.assertEqual(), self.assertTrue(), etc.</td>
<td>Simple assert statements</td>
</tr>
<tr>
<td><strong>Fixtures</strong></td>
<td>setUp()/tearDown() methods</td>
<td>@pytest.fixture decorator</td>
</tr>
<tr>
<td><strong>Discovery</strong></td>
<td>python -m unittest discover</td>
<td>Just run "pytest"</td>
</tr>
<tr>
<td><strong>Learning Curve</strong></td>
<td>Steeper (more boilerplate)</td>
<td>Gentler (less boilerplate)</td>
</tr>
</tbody>
</table>
<h3>Writing Tests: unittest Approach</h3>
<div class="code-block"><code>import unittest
from network_monitor import parse_packet_line, is_port_scan, NetworkPacket

class TestNetworkMonitor(unittest.TestCase):
    """Test suite for network monitoring functions."""
    
    def setUp(self):
        """Set up test fixtures - runs before each test."""
        self.valid_packet_line = "192.168.1.5,10.0.0.1,54321,443,TCP,SYN"
        self.config = NetworkConfig(port_scan_threshold=25)
    
    def tearDown(self):
        """Clean up after tests - runs after each test."""
        pass
    
    def test_parse_valid_packet(self):
        """Test parsing a valid packet line."""
        packet = parse_packet_line(self.valid_packet_line)
        
        self.assertEqual(packet.src_ip, "192.168.1.5")
        self.assertEqual(packet.dst_ip, "10.0.0.1")
        self.assertEqual(packet.src_port, 54321)
        self.assertEqual(packet.dst_port, 443)
        self.assertEqual(packet.protocol, "TCP")
        self.assertEqual(packet.flags, "SYN")
    
    def test_parse_invalid_packet_too_few_fields(self):
        """Test parsing packet with too few fields."""
        invalid_line = "192.168.1.5,10.0.0.1,443"
        
        with self.assertRaises(ValueError):
            parse_packet_line(invalid_line)
    
    def test_parse_invalid_ip_address(self):
        """Test parsing packet with invalid IP."""
        invalid_line = "999.999.999.999,10.0.0.1,54321,443,TCP,SYN"
        
        with self.assertRaises(ValueError):
            parse_packet_line(invalid_line)
    
    def test_port_scan_detection_below_threshold(self):
        """Test that port scan is not detected below threshold."""
        src_ip = "192.168.1.5"
        target_ports = {80, 443, 22}  # Only 3 ports
        
        result = is_port_scan(src_ip, target_ports, threshold=25)
        
        self.assertFalse(result)
    
    def test_port_scan_detection_above_threshold(self):
        """Test that port scan is detected above threshold."""
        src_ip = "192.168.1.5"
        # Create set of 30 ports
        target_ports = set(range(1, 31))
        
        result = is_port_scan(src_ip, target_ports, threshold=25)
        
        self.assertTrue(result)
    
    def test_port_scan_detection_exactly_at_threshold(self):
        """Test edge case: exactly at threshold (should not trigger)."""
        src_ip = "192.168.1.5"
        target_ports = set(range(1, 26))  # Exactly 25 ports
        
        result = is_port_scan(src_ip, target_ports, threshold=25)
        
        self.assertFalse(result)  # &gt; threshold, not &gt;= threshold

if __name__ == '__main__':
    unittest.main()</code></div>
<h3>Writing Tests: pytest Approach</h3>
<div class="code-block"><code>import pytest
from network_monitor import parse_packet_line, is_port_scan, NetworkPacket

# Fixtures - reusable test data
@pytest.fixture
def valid_packet_line():
    """Sample valid packet line."""
    return "192.168.1.5,10.0.0.1,54321,443,TCP,SYN"

@pytest.fixture
def config():
    """Sample configuration."""
    return NetworkConfig(port_scan_threshold=25)

# Tests - simple functions with assert
def test_parse_valid_packet(valid_packet_line):
    """Test parsing a valid packet line."""
    packet = parse_packet_line(valid_packet_line)
    
    assert packet.src_ip == "192.168.1.5"
    assert packet.dst_ip == "10.0.0.1"
    assert packet.src_port == 54321
    assert packet.dst_port == 443
    assert packet.protocol == "TCP"
    assert packet.flags == "SYN"

def test_parse_invalid_packet_too_few_fields():
    """Test parsing packet with too few fields."""
    invalid_line = "192.168.1.5,10.0.0.1,443"
    
    with pytest.raises(ValueError):
        parse_packet_line(invalid_line)

def test_parse_invalid_ip_address():
    """Test parsing packet with invalid IP."""
    invalid_line = "999.999.999.999,10.0.0.1,54321,443,TCP,SYN"
    
    with pytest.raises(ValueError):
        parse_packet_line(invalid_line)

def test_port_scan_detection_below_threshold():
    """Test that port scan is not detected below threshold."""
    src_ip = "192.168.1.5"
    target_ports = {80, 443, 22}
    
    result = is_port_scan(src_ip, target_ports, threshold=25)
    
    assert result is False

def test_port_scan_detection_above_threshold():
    """Test that port scan is detected above threshold."""
    src_ip = "192.168.1.5"
    target_ports = set(range(1, 31))  # 30 ports
    
    result = is_port_scan(src_ip, target_ports, threshold=25)
    
    assert result is True

def test_port_scan_detection_exactly_at_threshold():
    """Test edge case: exactly at threshold."""
    src_ip = "192.168.1.5"
    target_ports = set(range(1, 26))  # Exactly 25
    
    result = is_port_scan(src_ip, target_ports, threshold=25)
    
    assert result is False

# Parametrized tests - run same test with different data
@pytest.mark.parametrize("port_count,threshold,expected", [
    (10, 25, False),   # Below threshold
    (25, 25, False),   # At threshold
    (26, 25, True),    # Above threshold
    (100, 25, True),   # Way above
    (1, 10, False),    # Single port
])
def test_port_scan_various_scenarios(port_count, threshold, expected):
    """Test port scan detection with various inputs."""
    src_ip = "192.168.1.5"
    target_ports = set(range(1, port_count + 1))
    
    result = is_port_scan(src_ip, target_ports, threshold=threshold)
    
    assert result is expected</code></div>
<h3>What Makes a Good Test?</h3>
<div class="tip-box">
<h4>The FIRST Principles of Testing</h4>
<ul>
<li><strong>Fast:</strong> Tests should run in milliseconds</li>
<li><strong>Independent:</strong> Tests don't depend on each other</li>
<li><strong>Repeatable:</strong> Same results every time</li>
<li><strong>Self-validating:</strong> Pass or fail, no manual checking</li>
<li><strong>Timely:</strong> Written before or with the code, not after</li>
</ul>
</div>
<h3>Test Categories to Cover</h3>
<h4>1. Happy Path Tests</h4>
<div class="code-block"><code># Test normal, expected usage
def test_parse_valid_packet():
    """Test with valid, well-formed input."""
    packet = parse_packet_line("192.168.1.5,10.0.0.1,54321,443,TCP,SYN")
    assert packet.src_ip == "192.168.1.5"</code></div>
<h4>2. Edge Case Tests</h4>
<div class="code-block"><code># Test boundaries and limits
def test_port_scan_exactly_at_threshold():
    """Test when count exactly equals threshold."""
    # Important: is it &gt; or &gt;= ?
    pass

def test_empty_packet_list():
    """Test with no packets."""
    results = analyze_packets([])
    assert results['total'] == 0</code></div>
<h4>3. Error Case Tests</h4>
<div class="code-block"><code># Test invalid inputs and errors
def test_parse_malformed_packet():
    """Test with badly formatted input."""
    with pytest.raises(ValueError):
        parse_packet_line("not,valid,packet")

def test_file_not_found():
    """Test with non-existent file."""
    with pytest.raises(FileNotFoundError):
        load_packets("nonexistent.log")</code></div>
<h4>4. Security-Specific Tests</h4>
<div class="code-block"><code># Test security detection logic
def test_syn_flood_detection():
    """Test SYN flood attack detection."""
    # Create 150 SYN packets from same source
    packets = [create_syn_packet("192.168.1.5") for _ in range(150)]
    
    results = analyze_packets(packets, config)
    
    assert "192.168.1.5" in results['suspicious_ips']
    assert results['alerts'][0]['type'] == 'SYN_FLOOD'

def test_no_false_positives_normal_traffic():
    """Ensure normal traffic doesn't trigger alerts."""
    packets = create_normal_traffic_sample()
    
    results = analyze_packets(packets, config)
    
    assert len(results['suspicious_ips']) == 0</code></div>
<div class="warning-box">
<h4>‚ö†Ô∏è Common Testing Mistakes</h4>
<ol>
<li><strong>Testing implementation, not behavior:</strong> Test what the function does, not how it does it</li>
<li><strong>Tests that are too broad:</strong> One test should check one thing</li>
<li><strong>Ignoring edge cases:</strong> Off-by-one errors, empty inputs, null values</li>
<li><strong>No negative tests:</strong> Test that invalid inputs are rejected</li>
<li><strong>Tests with external dependencies:</strong> Use mocks for files, networks, databases</li>
</ol>
</div>
<h3>Running Your Tests</h3>
<div class="code-block"><code># unittest
python -m unittest test_network_monitor.py
python -m unittest discover  # Find all tests

# pytest
pytest test_network_monitor.py
pytest -v  # Verbose output
pytest --cov=network_monitor  # With coverage report
pytest -k "port_scan"  # Run only port scan tests</code></div>
</div>
<!-- CLI TAB -->
<div id="cli" class="tab-content">
<h2>‚å®Ô∏è CLI Design: Professional Command-Line Interfaces</h2>
<div class="info-box">
<h3>Why CLI Design Matters</h3>
<p>Security tools are often run from the command line in automated pipelines. A well-designed CLI:</p>
<ul>
<li>Is self-documenting with --help</li>
<li>Follows Unix conventions (flags, exit codes)</li>
<li>Provides clear error messages</li>
<li>Is automation-friendly</li>
<li>Validates inputs early</li>
</ul>
</div>
<h3>From sys.argv to argparse</h3>
<div class="comparison-container">
<div class="before-code">
<h4>‚ùå Manual Argument Parsing</h4>
<div class="code-block"><code>import sys

# Brittle and error-prone
if len(sys.argv) &lt; 2:
    print("Usage: script.py <file>")
    sys.exit(1)

file_path = sys.argv[1]

# No validation
# No --help
# Hard to add options
# No type checking</file></code></div>
</div>
<div class="after-code">
<h4>‚úÖ Using argparse</h4>
<div class="code-block"><code>import argparse

parser = argparse.ArgumentParser(
    description='Network traffic analyzer'
)

parser.add_argument(
    'input_file',
    help='Path to network traffic log'
)

parser.add_argument(
    '--output', '-o',
    help='Output file for results',
    default='results.json'
)

args = parser.parse_args()

# Automatic --help
# Type validation
# Clear errors</code></div>
</div>
</div>
<h3>Complete CLI Example</h3>
<div class="code-block"><code>#!/usr/bin/env python3
"""
Network Traffic Monitor - Detect suspicious network patterns

Usage:
    ./network_monitor.py traffic.log
    ./network_monitor.py traffic.log --output results.json --threshold 50
    ./network_monitor.py traffic.log -v --log-level DEBUG
"""

import argparse
import sys
import logging
from pathlib import Path

def create_parser() -&gt; argparse.ArgumentParser:
    """Create and configure argument parser."""
    
    parser = argparse.ArgumentParser(
        description='Analyze network traffic for suspicious patterns',
        epilog='Example: %(prog)s traffic.log --output report.json',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter  # Show defaults
    )
    
    # Positional arguments
    parser.add_argument(
        'input_file',
        type=Path,
        help='Path to network traffic log file (CSV format)'
    )
    
    # Optional arguments
    parser.add_argument(
        '--output', '-o',
        type=Path,
        default=Path('results.json'),
        help='Output file for analysis results'
    )
    
    parser.add_argument(
        '--port-scan-threshold',
        type=int,
        default=25,
        metavar='N',
        help='Number of ports before flagging as port scan'
    )
    
    parser.add_argument(
        '--syn-flood-threshold',
        type=int,
        default=100,
        metavar='N',
        help='Number of SYN packets before flagging as flood'
    )
    
    parser.add_argument(
        '--log-file',
        type=Path,
        default=Path('network_monitor.log'),
        help='Path to log file'
    )
    
    parser.add_argument(
        '--log-level',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
        default='INFO',
        help='Logging verbosity level'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose output (equivalent to --log-level DEBUG)'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 1.0.0'
    )
    
    return parser

def validate_args(args: argparse.Namespace) -&gt; None:
    """Validate command-line arguments."""
    
    # Check input file exists
    if not args.input_file.exists():
        raise FileNotFoundError(f"Input file not found: {args.input_file}")
    
    # Check input file is readable
    if not args.input_file.is_file():
        raise ValueError(f"Input path is not a file: {args.input_file}")
    
    # Check thresholds are positive
    if args.port_scan_threshold &lt; 1:
        raise ValueError("Port scan threshold must be positive")
    
    if args.syn_flood_threshold &lt; 1:
        raise ValueError("SYN flood threshold must be positive")
    
    # Adjust log level if verbose
    if args.verbose:
        args.log_level = 'DEBUG'

def main():
    """Main entry point for CLI."""
    
    # Parse arguments
    parser = create_parser()
    args = parser.parse_args()
    
    try:
        # Validate arguments
        validate_args(args)
        
        # Setup logging
        logger = setup_logging(
            log_file=str(args.log_file),
            log_level=args.log_level
        )
        
        logger.info("Network Monitor v1.0.0 starting")
        logger.info("Input file: %s", args.input_file)
        logger.info("Output file: %s", args.output)
        
        # Create configuration
        config = NetworkConfig(
            port_scan_threshold=args.port_scan_threshold,
            syn_flood_threshold=args.syn_flood_threshold
        )
        
        # Run analysis
        results = analyze_traffic(str(args.input_file), config)
        
        # Save results
        save_results(results, str(args.output))
        
        # Print summary
        print(f"\n‚úì Analysis complete")
        print(f"  Total packets: {results['total']}")
        print(f"  Suspicious IPs: {len(results['suspicious_ips'])}")
        print(f"  Port scans detected: {len(results['port_scans'])}")
        print(f"\n  Results saved to: {args.output}")
        print(f"  Log file: {args.log_file}")
        
        # Exit with success
        return 0
        
    except FileNotFoundError as e:
        print(f"ERROR: {{e}}", file=sys.stderr)
        return 1
    
    except ValueError as e:
        print(f"ERROR: Invalid argument - {{e}}", file=sys.stderr)
        return 1
    
    except Exception as e:
        print(f"ERROR: {{e}}", file=sys.stderr)
        logging.exception("Unexpected error")
        return 2

if __name__ == '__main__':
    sys.exit(main())</code></div>
<h3>CLI Best Practices</h3>
<h4>1. Provide Excellent Help Text</h4>
<div class="code-block"><code># Good help text is:
# - Descriptive but concise
# - Shows examples
# - Explains valid values

parser.add_argument(
    '--threshold',
    type=int,
    default=25,
    metavar='N',  # Shows "N" in help instead of "THRESHOLD"
    help='Threshold for port scan detection (default: 25). '
         'Values between 10-50 are typical.'
)

# Shows in help:
#   --threshold N  Threshold for port scan detection (default: 25).
#                  Values between 10-50 are typical.</code></div>
<h4>2. Use Appropriate Argument Types</h4>
<div class="code-block"><code>from pathlib import Path

parser.add_argument(
    'input_file',
    type=Path,  # Automatically converts to Path object
    help='Input file path'
)

parser.add_argument(
    '--threshold',
    type=int,  # Validates as integer
    help='Detection threshold'
)

parser.add_argument(
    '--format',
    choices=['json', 'csv', 'xml'],  # Only these values allowed
    default='json',
    help='Output format'
)</code></div>
<h4>3. Use Mutually Exclusive Groups</h4>
<div class="code-block"><code># Can't use both --verbose and --quiet
group = parser.add_mutually_exclusive_group()
group.add_argument('--verbose', '-v', action='store_true')
group.add_argument('--quiet', '-q', action='store_true')</code></div>
<h4>4. Support Both Long and Short Options</h4>
<div class="code-block"><code>parser.add_argument('--output', '-o', help='Output file')
parser.add_argument('--verbose', '-v', action='store_true')
parser.add_argument('--threshold', '-t', type=int, default=25)

# Users can use either:
# --output results.json  or  -o results.json
# --verbose              or  -v
# --threshold 50         or  -t 50</code></div>
<h4>5. Use Proper Exit Codes</h4>
<div class="code-block"><code>def main():
    try:
        # ... do work ...
        return 0  # Success
        
    except FileNotFoundError:
        print("ERROR: File not found", file=sys.stderr)
        return 1  # General error
    
    except KeyboardInterrupt:
        print("\nAborted by user", file=sys.stderr)
        return 130  # SIGINT (Ctrl+C)
    
    except Exception as e:
        print(f"FATAL: {{e}}", file=sys.stderr)
        return 2  # Serious error

if __name__ == '__main__':
    sys.exit(main())

# Exit codes:
# 0 = Success
# 1 = General error
# 2 = Serious error
# 130 = User interrupted (Ctrl+C)</code></div>
<div class="tip-box">
<h4>üí° CLI Design Principles</h4>
<ul>
<li><strong>Be consistent:</strong> Follow conventions (--help, --version, etc.)</li>
<li><strong>Validate early:</strong> Check arguments before doing work</li>
<li><strong>Fail gracefully:</strong> Clear error messages, proper exit codes</li>
<li><strong>Be automation-friendly:</strong> Machine-readable output options</li>
<li><strong>Respect stdin/stdout/stderr:</strong> Output goes to stdout, errors to stderr</li>
<li><strong>Support piping:</strong> Read from stdin when no file specified</li>
</ul>
</div>
<h3>Testing Your CLI</h3>
<div class="code-block"><code># Test the help text
./network_monitor.py --help

# Test with valid input
./network_monitor.py traffic.log

# Test with options
./network_monitor.py traffic.log --threshold 50 -v

# Test error handling
./network_monitor.py nonexistent.log  # Should show clear error

# Test validation
./network_monitor.py traffic.log --threshold -5  # Should reject

# Check exit codes
./network_monitor.py traffic.log
echo $?  # Should print 0 on success</code></div>
</div>
<!-- AI TAB -->
<div id="ai" class="tab-content">
<h2>ü§ñ AI-Assisted Development</h2>
<div class="info-box">
<h3>AI as Your Refactoring Partner</h3>
<p>AI tools like GitHub Copilot can accelerate refactoring and testing, but you must use them <strong>critically</strong>. AI is a powerful assistant, not a replacement for understanding.</p>
<p><strong>Key principle:</strong> AI suggests, you decide.</p>
</div>
<h3>Effective AI Prompting for Refactoring</h3>
<h4>1. Breaking Down Large Functions</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"I have a 150-line function that analyzes network traffic. It does parsing, port scan detection, SYN flood detection, and reporting all in one function. Help me break this into smaller, testable functions. Each function should have a single responsibility and be pure (no side effects) if possible."</div>
<p><strong>Why this works:</strong> Specific goal, mentions testing and purity, gives context</p>
</div>
<h4>2. Extracting Configuration</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"This code has magic numbers scattered throughout (25, 100, 1024). Help me extract these into a configuration class with meaningful names and docstrings explaining what each threshold represents."</div>
<p><strong>Why this works:</strong> Identifies specific problem (magic numbers), clear desired outcome</p>
</div>
<h4>3. Adding Logging</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"Add proper Python logging to this function. Use appropriate log levels: DEBUG for detailed flow, INFO for key events, WARNING for suspicious patterns, ERROR for failures. Include context in log messages (IP addresses, packet counts, etc.)."</div>
<p><strong>Why this works:</strong> Specifies logging levels and what to log at each level</p>
</div>
<h4>4. Error Handling</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"Add comprehensive error handling to this packet parsing function. Handle: missing fields, invalid IP addresses, non-numeric ports, invalid protocols. Each error should have a clear message indicating what's wrong and what was expected."</div>
<p><strong>Why this works:</strong> Lists specific error cases, specifies error message requirements</p>
</div>
<h3>Effective AI Prompting for Testing</h3>
<h4>1. Generating Initial Test Cases</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"Generate pytest test cases for this parse_packet_line() function. Include: - Happy path test with valid input - Test with missing fields - Test with invalid IP address - Test with negative port number - Test with empty string - Test with extra whitespace Use clear, descriptive test names and docstrings."</div>
<p><strong>Why this works:</strong> Specific test scenarios, mentions pytest, asks for documentation</p>
</div>
<h4>2. Edge Case Discovery</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"This function detects port scans when target_ports &gt; threshold. What edge cases should I test? Consider: exactly at threshold, empty port set, threshold of zero, very large port count, etc. Suggest 5 edge case tests."</div>
<p><strong>Why this works:</strong> Asks AI to think about edge cases, gives examples to prompt thinking</p>
</div>
<h4>3. Security-Specific Test Cases</h4>
<div class="ai-prompt-box">
<h4>ü§ñ AI Prompt Example</h4>
<div class="prompt-text">"This is a network traffic analyzer that detects SYN flood attacks. What security-specific test cases should I write? Consider: true positive detection, false positive prevention, evasion techniques, threshold tuning, performance under load."</div>
<p><strong>Why this works:</strong> Focuses on security domain, mentions key security testing concerns</p>
</div>
<h3>Critical AI Usage Guidelines</h3>
<div class="warning-box">
<h4>‚ö†Ô∏è Don't Trust AI Blindly</h4>
<p><strong>AI Code Review Checklist:</strong></p>
<ol>
<li><strong>Does it actually work?</strong> Run the code, don't assume it's correct</li>
<li><strong>Does it handle errors?</strong> AI often forgets edge cases</li>
<li><strong>Is it secure?</strong> AI might suggest vulnerable patterns</li>
<li><strong>Is it testable?</strong> AI sometimes generates hard-to-test code</li>
<li><strong>Do you understand it?</strong> Never commit code you don't understand</li>
<li><strong>Is it Pythonic?</strong> AI might use patterns from other languages</li>
<li><strong>Are tests meaningful?</strong> AI can generate tests that pass but don't test anything useful</li>
</ol>
</div>
<h3>AI Workflow for Refactoring</h3>
<div class="code-block"><code># Step 1: Ask AI for refactoring suggestions
# Prompt: "How can I refactor this function to be more testable?"

# Step 2: Review AI suggestions critically
# - Does it make sense?
# - Is it actually better?
# - Does it maintain correctness?

# Step 3: Implement one change at a time
# - Refactor one function
# - Run existing tests (if any)
# - Write new tests for refactored code

# Step 4: Use AI to generate test cases
# Prompt: "Generate pytest tests for this refactored function"

# Step 5: Review and modify AI-generated tests
# - Remove redundant tests
# - Add missing edge cases
# - Improve test names and docs

# Step 6: Verify everything works
# - Run all tests
# - Test manually
# - Code review

# Step 7: Iterate
# - Refactor next function
# - Repeat process</code></div>
<h3>When AI is Helpful vs. Harmful</h3>
<table>
<tbody>
<tr>
<th>Good Use Cases</th>
<th>Bad Use Cases</th>
</tr>
<tr>
<td>Generating boilerplate code</td>
<td>Blindly accepting security-critical code</td>
</tr>
<tr>
<td>Suggesting function names</td>
<td>Copying complex algorithms without understanding</td>
</tr>
<tr>
<td>Proposing test case ideas</td>
<td>Using AI-generated tests as the only tests</td>
</tr>
<tr>
<td>Finding edge cases you missed</td>
<td>Letting AI make architectural decisions</td>
</tr>
<tr>
<td>Converting between testing frameworks</td>
<td>Generating tests for code you don't understand</td>
</tr>
<tr>
<td>Drafting docstrings and comments</td>
<td>Relying on AI for debugging without understanding the bug</td>
</tr>
</tbody>
</table>
<div class="tip-box">
<h4>üí° AI Best Practices</h4>
<ul>
<li><strong>Be specific in prompts:</strong> Vague prompts get vague answers</li>
<li><strong>Iterate on suggestions:</strong> Use "Make this more testable" or "Add error handling"</li>
<li><strong>Ask for explanations:</strong> "Why did you structure it this way?"</li>
<li><strong>Request alternatives:</strong> "Show me 3 different ways to solve this"</li>
<li><strong>Use AI for exploration:</strong> "What are common security bugs in parsers?"</li>
<li><strong>Always test AI code:</strong> It often looks good but has subtle bugs</li>
<li><strong>Learn from AI:</strong> Study patterns it suggests, don't just copy</li>
</ul>
</div>
<h3>Example AI-Assisted Refactoring Session</h3>
<div class="scenario-box">
<h3>Real-World Example: Refactoring with AI</h3>
<p><strong>Starting Point:</strong> Messy 150-line analyze_traffic() function</p>
<p><strong>Round 1: Initial refactoring</strong></p>
<p><em>Prompt:</em> "Break this function into smaller functions with single responsibilities"</p>
<p><em>AI suggests:</em> load_packets(), parse_line(), detect_port_scan(), detect_syn_flood(), generate_report()</p>
<p><em>Your action:</em> Review, implement load_packets() and parse_line() first, test them</p>
<p><strong>Round 2: Improve testability</strong></p>
<p><em>Prompt:</em> "Make detect_port_scan() a pure function with no side effects"</p>
<p><em>AI suggests:</em> Remove global variables, return results instead of printing</p>
<p><em>Your action:</em> Implement suggestion, write unit tests</p>
<p><strong>Round 3: Add logging</strong></p>
<p><em>Prompt:</em> "Add logging to detect_port_scan() with appropriate levels"</p>
<p><em>AI suggests:</em> DEBUG for each check, WARNING for detections</p>
<p><em>Your action:</em> Review and refine log messages for clarity</p>
<p><strong>Round 4: Generate tests</strong></p>
<p><em>Prompt:</em> "Generate pytest tests for detect_port_scan() including edge cases"</p>
<p><em>AI suggests:</em> 8 test cases</p>
<p><em>Your action:</em> Review, remove 2 redundant tests, add 1 missing edge case</p>
<p><strong>Result:</strong> Clean, modular, well-tested code in ~2 hours instead of ~6 hours</p>
</div>
</div>
<!-- EXERCISES TAB -->
<div id="exercises" class="tab-content">
<h2>üíª Hands-On Exercises</h2>
<div class="info-box">
<h3>How to Approach These Exercises</h3>
<ol>
<li>Read the exercise description carefully</li>
<li>Plan your approach before coding</li>
<li>Write the code in small increments</li>
<li>Test each piece as you go</li>
<li>Use AI assistance when stuck, but understand the suggestions</li>
<li>Compare your solution with the provided solution</li>
</ol>
</div>
<!-- Exercise 1 -->
<div class="exercise-box">
<h3>Exercise 1: Extract Configuration Class</h3>
<p><strong>Objective:</strong> Remove magic numbers by creating a configuration class</p>
<p><strong>Task:</strong> The code below has several hardcoded thresholds. Create a <code>NetworkConfig</code> class to manage these values with clear names and docstrings.</p>
<div class="code-block"><span class="code-label">STARTER CODE</span> <code># Magic numbers everywhere!
if syn_count &gt; 100:
    alert("SYN flood")

if len(ports) &gt; 25:
    alert("Port scan")

if packet_rate &gt; 1000:
    alert("DoS attack")

if failed_logins &gt; 5:
    alert("Brute force")</code></div>
<p><strong>Your task:</strong></p>
<ul>
<li>Create a <code>NetworkConfig</code> class with class-level constants</li>
<li>Add an <code>__init__</code> method to allow customization</li>
<li>Include docstrings explaining what each threshold means</li>
<li>Replace all hardcoded numbers in the code with config values</li>
</ul>
<textarea id="exercise1" class="exercise-input" placeholder="Write your NetworkConfig class here..."></textarea> <button class="btn" onclick="checkExercise(1)">Check Solution</button> <button class="btn btn-secondary" onclick="showHint(1)">Show Hint</button> <button class="btn btn-secondary" onclick="resetExercise(1)">Reset</button>
<div id="feedback1" class="feedback"></div>
</div>
<!-- Exercise 2 -->
<div class="exercise-box">
<h3>Exercise 2: Refactor to Pure Functions</h3>
<p><strong>Objective:</strong> Transform a function with side effects into testable pure functions</p>
<p><strong>Task:</strong> The function below mixes I/O, parsing, and logic. Break it into separate, testable functions.</p>
<div class="code-block"><span class="code-label">STARTER CODE</span> <code>def process_log(filename):
    total = 0
    suspicious = 0
    
    f = open(filename, 'r')
    for line in f:
        total += 1
        parts = line.split(',')
        ip = parts[0]
        port = int(parts[3])
        
        if port &lt; 1024 and ip.startswith("192.168"):
            suspicious += 1
            print(f"Suspicious: {{ip}}:{{port}}")
    
    f.close()
    print(f"Total: {{total}}, Suspicious: {{suspicious}}")
    return suspicious / total if total &gt; 0 else 0</code></div>
<p><strong>Your task:</strong> Create these pure functions:</p>
<ul>
<li><code>load_lines(filename: str) -&gt; list</code> - I/O only</li>
<li><code>parse_log_line(line: str) -&gt; dict</code> - Parsing only</li>
<li><code>is_suspicious(ip: str, port: int) -&gt; bool</code> - Logic only</li>
<li><code>analyze_logs(lines: list) -&gt; dict</code> - Orchestration</li>
</ul>
<textarea id="exercise2" class="exercise-input" placeholder="Write your refactored functions here..."></textarea> <button class="btn" onclick="checkExercise(2)">Check Solution</button> <button class="btn btn-secondary" onclick="showHint(2)">Show Hint</button> <button class="btn btn-secondary" onclick="resetExercise(2)">Reset</button>
<div id="feedback2" class="feedback"></div>
</div>
<!-- Exercise 3 -->
<div class="exercise-box">
<h3>Exercise 3: Add Proper Logging</h3>
<p><strong>Objective:</strong> Replace print() statements with structured logging</p>
<p><strong>Task:</strong> The function below uses print() for diagnostics. Replace with proper logging using appropriate log levels.</p>
<div class="code-block"><span class="code-label">STARTER CODE</span> <code>def detect_anomalies(packets):
    print("Starting anomaly detection")
    anomalies = []
    
    for packet in packets:
        print(f"Checking packet from {packet['src_ip']}")
        
        if packet['size'] &gt; 1500:
            print(f"Oversized packet: {packet['size']} bytes")
            anomalies.append(packet)
        
        if packet['protocol'] not in ['TCP', 'UDP', 'ICMP']:
            print(f"ERROR: Unknown protocol {packet['protocol']}")
    
    print(f"Found {len(anomalies)} anomalies")
    return anomalies</code></div>
<p><strong>Your task:</strong></p>
<ul>
<li>Import and configure logging module</li>
<li>Use DEBUG for detailed packet-by-packet info</li>
<li>Use INFO for start/completion messages</li>
<li>Use WARNING for anomaly detection</li>
<li>Use ERROR for invalid data</li>
</ul>
<textarea id="exercise3" class="exercise-input" placeholder="Write your logging-enhanced function here..."></textarea> <button class="btn" onclick="checkExercise(3)">Check Solution</button> <button class="btn btn-secondary" onclick="showHint(3)">Show Hint</button> <button class="btn btn-secondary" onclick="resetExercise(3)">Reset</button>
<div id="feedback3" class="feedback"></div>
</div>
<!-- Exercise 4 -->
<div class="exercise-box">
<h3>Exercise 4: Write Unit Tests</h3>
<p><strong>Objective:</strong> Write comprehensive tests for a parser function</p>
<p><strong>Task:</strong> Write pytest tests for this packet parser function. Include happy path, edge cases, and error cases.</p>
<div class="code-block"><span class="code-label">FUNCTION TO TEST</span> <code>def parse_packet(line: str) -&gt; dict:
    """Parse packet line: src_ip,dst_ip,src_port,dst_port,protocol"""
    parts = line.strip().split(',')
    
    if len(parts) != 5:
        raise ValueError(f"Expected 5 fields, got {len(parts)}")
    
    src_ip, dst_ip, src_port, dst_port, protocol = parts
    
    return {
        'src_ip': src_ip,
        'dst_ip': dst_ip,
        'src_port': int(src_port),
        'dst_port': int(dst_port),
        'protocol': protocol.upper()
    }</code></div>
<p><strong>Your task:</strong> Write tests for:</p>
<ul>
<li>Valid packet line (happy path)</li>
<li>Too few fields</li>
<li>Too many fields</li>
<li>Non-numeric port</li>
<li>Empty string</li>
<li>Extra whitespace handling</li>
<li>Protocol case handling</li>
</ul>
<textarea id="exercise4" class="exercise-input" placeholder="Write your pytest test functions here..."></textarea> <button class="btn" onclick="checkExercise(4)">Check Solution</button> <button class="btn btn-secondary" onclick="showHint(4)">Show Hint</button> <button class="btn btn-secondary" onclick="resetExercise(4)">Reset</button>
<div id="feedback4" class="feedback"></div>
</div>
<!-- Exercise 5 -->
<div class="exercise-box">
<h3>Exercise 5: Build Professional CLI</h3>
<p><strong>Objective:</strong> Create a complete argparse CLI with validation</p>
<p><strong>Task:</strong> Create a CLI for the network monitor with proper argument parsing, validation, and help text.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Positional argument: <code>input_file</code> (required)</li>
<li>Option: <code>--output</code> or <code>-o</code> (default: "results.json")</li>
<li>Option: <code>--threshold</code> or <code>-t</code> (default: 25, must be positive)</li>
<li>Option: <code>--verbose</code> or <code>-v</code> (flag)</li>
<li>Validate that input file exists</li>
<li>Validate that threshold is positive</li>
<li>Return proper exit codes</li>
</ul>
<textarea id="exercise5" class="exercise-input" placeholder="Write your CLI code here..."></textarea> <button class="btn" onclick="checkExercise(5)">Check Solution</button> <button class="btn btn-secondary" onclick="showHint(5)">Show Hint</button> <button class="btn btn-secondary" onclick="resetExercise(5)">Reset</button>
<div id="feedback5" class="feedback"></div>
</div>
<div class="tip-box">
<h4>üí° Exercise Tips</h4>
<ul>
<li><strong>Test as you go:</strong> Don't wait until the end to test your code</li>
<li><strong>Use AI strategically:</strong> Ask for hints or approaches, not complete solutions</li>
<li><strong>Read error messages carefully:</strong> They tell you what's wrong</li>
<li><strong>Start simple:</strong> Get basic version working before adding complexity</li>
<li><strong>Compare solutions:</strong> Your approach doesn't need to match exactly</li>
</ul>
</div>
</div>
<!-- PROGRESS TAB -->
<div id="progress" class="tab-content">
<h2>üìä Your Progress Tracker</h2>
<div class="info-box">
<p>Track your learning journey through Week 12. Click items to mark them complete!</p>
</div>
<div class="progress-tracker">
<h3 style="color: #ff3333; margin-bottom: 20px;">Core Concepts</h3>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Understand the purpose and benefits of refactoring</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Know when and how to extract functions</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Replace magic numbers with configuration classes</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Separate I/O from business logic</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Understand difference between print() and logging</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Know when to use each log level (DEBUG/INFO/WARNING/ERROR)</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Set up logging with file and console handlers</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Write effective log messages with context</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Understand the FIRST principles of testing</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Write tests using unittest framework</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Write tests using pytest framework</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Cover happy path, edge cases, and error cases</span></div>
</div>
<div class="progress-tracker">
<h3 style="color: #ff3333; margin-bottom: 20px;">Technical Skills</h3>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Create pure functions with no side effects</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Use argparse for command-line interfaces</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Validate CLI arguments properly</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Implement proper exit codes</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Use pytest fixtures for test data</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Write parametrized tests for multiple scenarios</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Handle errors with try/except blocks</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Add type hints to functions</span></div>
</div>
<div class="progress-tracker">
<h3 style="color: #ff3333; margin-bottom: 20px;">AI Integration</h3>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Write effective prompts for refactoring assistance</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Critically evaluate AI-generated code</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Use AI to generate initial test cases</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Identify when AI suggestions are wrong or insecure</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Iterate on AI suggestions to improve code</span></div>
</div>
<div class="progress-tracker">
<h3 style="color: #ff3333; margin-bottom: 20px;">Exercises Completed</h3>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Exercise 1: Extract Configuration Class</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Exercise 2: Refactor to Pure Functions</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Exercise 3: Add Proper Logging</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Exercise 4: Write Unit Tests</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Exercise 5: Build Professional CLI</span></div>
</div>
<div class="progress-tracker">
<h3 style="color: #ff3333; margin-bottom: 20px;">Final Project</h3>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Refactored network monitor into modular functions</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Added comprehensive logging to all functions</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Written full unit test suite (unittest or pytest)</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Implemented professional CLI with argparse</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>All tests passing with &gt;80% code coverage</span></div>
<div class="progress-item" onclick="toggleProgress(this)">
<div class="progress-checkbox"></div>
<span>Code reviewed and ready for submission</span></div>
</div>
<div class="tip-box" style="margin-top: 30px;">
<h4>üéØ Week 12 Success Criteria</h4>
<p>By the end of this week, you should be able to:</p>
<ul>
<li>Transform any messy script into clean, modular code</li>
<li>Add professional logging to any Python program</li>
<li>Write comprehensive unit tests with confidence</li>
<li>Build user-friendly command-line interfaces</li>
<li>Use AI tools effectively and critically</li>
<li>Apply these skills to the capstone project</li>
</ul>
</div>
</div>
</div>
<footer>
<p>Week 12: Mini Toolkit Refactor &amp; Testing | Cybersecurity Programming Course</p>
<p>Remember: Professional security tools require professional software engineering practices.</p>
</footer></div>
<p><script>
        // Tab switching
        function switchTab(tabId) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active from all nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            
            // Set active nav tab
            event.target.classList.add('active');
            
            // Save to localStorage
            localStorage.setItem('week12_activeTab', tabId);
        }

        // Progress tracking
        function toggleProgress(element) {
            element.classList.toggle('completed');
            const checkbox = element.querySelector('.progress-checkbox');
            
            if (element.classList.contains('completed')) {
                checkbox.textContent = '‚úì';
                
                // Save to localStorage
                saveProgress();
            } else {
                checkbox.textContent = '';
                saveProgress();
            }
            
            // Update progress bar
            updateProgressBar();
        }

        function updateProgressBar() {
            const allItems = document.querySelectorAll('.progress-item');
            const completedItems = document.querySelectorAll('.progress-item.completed');
            
            const total = allItems.length;
            const completed = completedItems.length;
            const remaining = total - completed;
            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
            
            // Update progress bar
            const progressFill = document.getElementById('progressBarFill');
            const progressPercentage = document.getElementById('progressPercentage');
            const completedCount = document.getElementById('completedCount');
            const totalCount = document.getElementById('totalCount');
            const remainingCount = document.getElementById('remainingCount');
            
            if (progressFill) {
                progressFill.style.width = percentage + '%';
                
                // Add celebration class at 100%
                if (percentage >= 100) {
                    progressFill.classList.add('complete');
                } else {
                    progressFill.classList.remove('complete');
                }
            }
            
            if (progressPercentage) progressPercentage.textContent = percentage + '%';
            if (completedCount) completedCount.textContent = completed;
            if (totalCount) totalCount.textContent = total;
            if (remainingCount) remainingCount.textContent = remaining;
            
            // Change color based on progress
            if (percentage >= 100) {
                if (progressPercentage) {
                    progressPercentage.style.color = '#00ff00';
                    progressPercentage.textContent = '100% COMPLETE! üéâ';
                }
            } else if (percentage >= 75) {
                if (progressPercentage) progressPercentage.style.color = '#00ff00';
            } else if (percentage >= 50) {
                if (progressPercentage) progressPercentage.style.color = '#ffaa00';
            } else {
                if (progressPercentage) progressPercentage.style.color = '#ff6666';
            }
        }

        function saveProgress() {
            const completed = [];
            document.querySelectorAll('.progress-item.completed').forEach(item => {
                completed.push(item.textContent.trim());
            });
            localStorage.setItem('week12_progress', JSON.stringify(completed));
        }

        function loadProgress() {
            const saved = localStorage.getItem('week12_progress');
            if (saved) {
                const completed = JSON.parse(saved);
                document.querySelectorAll('.progress-item').forEach(item => {
                    if (completed.includes(item.textContent.trim())) {
                        item.classList.add('completed');
                        item.querySelector('.progress-checkbox').textContent = '‚úì';
                    }
                });
            }
            
            // Update progress bar after loading
            updateProgressBar();
        }

        // Exercise feedback
        function showHint(exerciseNum) {
            const hints = {
                1: "Start with class NetworkConfig and define class-level constants like PORT_SCAN_THRESHOLD = 25. Add an __init__ method that allows overriding defaults. Don't forget docstrings!",
                2: "Break the function into: 1) load_lines() for file I/O, 2) parse_log_line() for parsing, 3) is_suspicious() for logic, 4) analyze_logs() to orchestrate. Each should be testable independently.",
                3: "Import logging at the top. Create a logger = logging.getLogger(__name__). Replace print statements with logger.debug(), logger.info(), logger.warning(), logger.error() as appropriate.",
                4: "Write test functions starting with 'test_'. Use pytest.raises() for testing exceptions. Don't forget to test edge cases like empty strings and extra whitespace.",
                5: "Create an ArgumentParser, add arguments with add_argument(), parse with parse_args(). Validate arguments in a separate function. Use try/except and return proper exit codes (0 for success, 1 for errors)."
            };
            
            const feedback = document.getElementById(`feedback${{exerciseNum}}`);
            feedback.textContent = `üí° Hint: ${hints[exerciseNum]}`;
            feedback.className = 'feedback';
            feedback.style.display = 'block';
            feedback.style.background = '#1a2e2e';
            feedback.style.border = '1px solid #00aa00';
            feedback.style.color = '#00ff00';
        }

        function checkExercise(exerciseNum) {
            const textarea = document.getElementById(`exercise${{exerciseNum}}`);
            const code = textarea.value.trim();
            const feedback = document.getElementById(`feedback${{exerciseNum}}`);
            
            if (code.length < 50) {
                feedback.textContent = '‚ùå Your solution seems too short. Try adding more code!';
                feedback.className = 'feedback error';
                return;
            }
            
            // Simple checks - in real implementation, you'd have more sophisticated validation
            const checks = {
                1: code.includes('class NetworkConfig') && code.includes('__init__'),
                2: code.includes('def load_lines') && code.includes('def parse_log_line') && code.includes('def is_suspicious'),
                3: code.includes('import logging') && code.includes('logger.'),
                4: code.includes('def test_') && (code.includes('assert') || code.includes('self.assert')),
                5: code.includes('argparse') && code.includes('ArgumentParser')
            };
            
            if (checks[exerciseNum]) {
                feedback.textContent = '‚úì Good work! Your solution includes the key elements. Compare with the provided solution to see different approaches.';
                feedback.className = 'feedback success';
                
                // Mark exercise as complete
                const progressItems = document.querySelectorAll('.progress-item');
                progressItems.forEach(item => {
                    if (item.textContent.includes(`Exercise ${{exerciseNum}}`)) {
                        item.classList.add('completed');
                        item.querySelector('.progress-checkbox').textContent = '‚úì';
                    }
                });
                saveProgress();
                updateProgressBar();
            } else {
                feedback.textContent = '‚ö†Ô∏è Your solution is missing some key elements. Check the requirements and try again, or use the hint button.';
                feedback.className = 'feedback error';
            }
        }

        function resetExercise(exerciseNum) {
            const textarea = document.getElementById(`exercise${{exerciseNum}}`);
            const feedback = document.getElementById(`feedback${{exerciseNum}}`);
            
            textarea.value = '';
            feedback.style.display = 'none';
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved tab
            const savedTab = localStorage.getItem('week12_activeTab');
            if (savedTab) {
                // Find the tab button and click it
                const tabs = document.querySelectorAll('.nav-tab');
                tabs.forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(savedTab.split('-')[0])) {
                        // Small delay to ensure DOM is ready
                        setTimeout(() => {
                            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                            document.getElementById(savedTab).classList.add('active');
                            tab.classList.add('active');
                        }, 100);
                    }
                });
            }
            
            // Load saved progress
            loadProgress();
        });
    </script></p></body></html>
